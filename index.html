<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Merger with Cover & Index Page</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- pdf-lib for PDF manipulation -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <!-- Google Fonts for typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the application */
        body {
            font-family: 'Inter', sans-serif;
        }
        .file-list-item, .detail-row, .section-container {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .file-list-item.dragging {
            opacity: 0.5;
            background-color: #e0e7ff;
        }
        .drag-over {
            border-top: 2px solid #4f46e5;
        }
        .drag-handle {
            cursor: move;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-3xl bg-white rounded-xl shadow-lg p-6 md:p-8">
        
        <!-- Main Header -->
        <div class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">PDF Index & Merger</h1>
            <p class="mt-2 text-gray-600">Create a master PDF with a cover page and a clickable table of contents.</p>
        </div>
        
        <!-- Cover Page Details Input Section -->
        <div class="mb-6 p-4 border border-gray-200 rounded-lg">
             <h2 class="text-lg font-semibold text-gray-700 mb-3">Cover Page Details (Optional)</h2>
             <div class="space-y-4">
                 <div>
                    <label for="cover-title" class="block text-sm font-medium text-gray-700">Title</label>
                    <input type="text" id="cover-title" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" placeholder="e.g., Quarterly Report">
                 </div>
                 
                 <div>
                    <label class="block text-sm font-medium text-gray-700">Description Details</label>
                    <div id="subject-details-container" class="mt-2 space-y-2"></div>
                    <button id="add-subject-row-btn" type="button" class="mt-2 text-sm font-medium text-blue-600 hover:text-blue-800">+ Add Detail</button>
                 </div>

                 <div>
                    <label for="cover-author" class="block text-sm font-medium text-gray-700">Author / Department</label>
                    <input type="text" id="cover-author" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" placeholder="e.g., Finance Department">
                 </div>
                 <div>
                    <label for="cover-image" class="block text-sm font-medium text-gray-700">Header Image</label>
                    <input type="file" id="cover-image" accept="image/png, image/jpeg" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                    <div id="image-preview" class="mt-2 hidden bg-gray-50 p-2 rounded-lg border border-gray-200">
                        <p class="text-xs font-medium text-gray-500 mb-2">Image Preview:</p>
                        <img id="preview-img" src="#" alt="Image Preview" class="max-h-24 rounded-md">
                    </div>
                </div>
                <div class="flex items-center">
                    <input id="include-date" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                    <label for="include-date" class="ml-2 block text-sm text-gray-900">Include current date on cover page</label>
                </div>
             </div>
        </div>

        <!-- Sections Management Area -->
        <div class="mb-6">
            <h2 class="text-lg font-semibold text-gray-700 mb-3">Document Sections</h2>
            <div id="sections-container" class="space-y-4">
                <!-- Sections will be dynamically added here -->
            </div>
            <div class="mt-4">
                <button id="add-section-btn" class="w-full flex justify-center items-center py-2 px-4 border border-dashed border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                    Add New Section
                </button>
            </div>
        </div>
        
        <!-- Action Buttons & Status -->
        <div class="mt-8 text-center">
            <button id="merge-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                Generate Merged PDF
            </button>
            <div id="status" class="mt-4 text-gray-600 h-6"></div>
        </div>

        <!-- Download Link -->
        <div id="download-container" class="mt-6 hidden text-center">
             <a id="download-link" class="w-full inline-block bg-green-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-700 transition-colors duration-300" download="merged-document.pdf">
                 Download Your PDF
             </a>
        </div>
    </div>

   <script>
    // Load required modules from pdf-lib
    const { PDFDocument, rgb, StandardFonts } = PDFLib;

    // DOM elements
    const mergeBtn = document.getElementById('merge-btn');
    const statusDiv = document.getElementById('status');
    const downloadContainer = document.getElementById('download-container');
    const downloadLink = document.getElementById('download-link');
    const coverTitleInput = document.getElementById('cover-title');
    const coverAuthorInput = document.getElementById('cover-author');
    const coverImageInput = document.getElementById('cover-image');
    const imagePreview = document.getElementById('image-preview');
    const previewImg = document.getElementById('preview-img');
    const includeDateCheckbox = document.getElementById('include-date');
    const subjectDetailsContainer = document.getElementById('subject-details-container');
    const addSubjectRowBtn = document.getElementById('add-subject-row-btn');
    const sectionsContainer = document.getElementById('sections-container');
    const addSectionBtn = document.getElementById('add-section-btn');

    // Main data structure for sections and files
    let sections = [];
    let fileIdCounter = 0; // Unique ID counter for files
    
    // --- UI Management ---
    function renderSections() {
        sectionsContainer.innerHTML = '';
        let totalFiles = 0;
        sections.forEach((section, sectionIndex) => {
            totalFiles += section.files.length;
            const sectionEl = document.createElement('div');
            sectionEl.className = 'section-container p-4 border border-gray-200 rounded-lg';
            sectionEl.setAttribute('data-section-index', sectionIndex);

            sectionEl.innerHTML = `
                <div class="flex justify-between items-center mb-3">
                    <input type="text" class="section-title-input text-lg font-semibold border-b-2 border-transparent focus:border-blue-500 focus:outline-none" value="${section.title}" placeholder="Section ${sectionIndex + 1} Title">
                    <button class="remove-section-btn text-red-500 hover:text-red-700 p-1">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                    </button>
                </div>
                <ul class="file-list space-y-2 mb-3">
                    ${section.files.map((file, fileIndex) => `
                        <li class="file-list-item flex items-center p-2 bg-gray-100 rounded-md" draggable="true" data-index="${fileIndex}">
                            <span class="drag-handle text-gray-500 mr-2"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v12a1 1 0 11-2 0V4a1 1 0 011-1zM4 9a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1z" clip-rule="evenodd" transform="rotate(90 10 10)" /></svg></span>
                            <div class="flex-grow overflow-hidden mr-2"><span class="font-medium text-sm truncate">${file.name}</span></div>
                            <div class="flex-shrink-0"><span class="text-xs text-gray-500 mr-4">${(file.size / 1024 / 1024).toFixed(2)} MB</span>
                            <button class="remove-file-btn text-red-500 hover:text-red-700"><svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg></button></div>
                        </li>
                    `).join('')}
                </ul>
                <label class="add-files-label flex justify-center w-full px-4 py-6 transition bg-white border-2 border-gray-300 border-dashed rounded-md appearance-none cursor-pointer hover:border-gray-400">
                    <span class="flex items-center space-x-2"><svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" /></svg>
                    <span class="font-medium text-gray-600">Drop files or <span class="text-blue-600 underline">browse</span></span></span>
                    <input type="file" multiple accept=".pdf" class="hidden add-files-input">
                </label>
            `;
            sectionsContainer.appendChild(sectionEl);
        });
        mergeBtn.disabled = totalFiles === 0;
    }

    // --- Event Handlers ---
    addSectionBtn.addEventListener('click', () => {
        sections.push({ title: `Section ${sections.length + 1}`, files: [] });
        renderSections();
    });

    sectionsContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('section-title-input')) {
            const sectionIndex = e.target.closest('.section-container').dataset.sectionIndex;
            sections[sectionIndex].title = e.target.value;
        }
        if (e.target.classList.contains('add-files-input')) {
            const sectionIndex = e.target.closest('.section-container').dataset.sectionIndex;
            const newFiles = Array.from(e.target.files);
            newFiles.forEach(file => {
                const isDuplicate = sections[sectionIndex].files.some(f => f.name === file.name && f.size === file.size);
                if (!isDuplicate) {
                    file.uniqueId = fileIdCounter++; // Assign unique ID
                    sections[sectionIndex].files.push(file);
                }
            });
            renderSections();
        }
    });

    sectionsContainer.addEventListener('click', (e) => {
        const removeSectionBtn = e.target.closest('.remove-section-btn');
        if (removeSectionBtn) {
            const sectionIndex = removeSectionBtn.closest('.section-container').dataset.sectionIndex;
            sections.splice(sectionIndex, 1);
            renderSections();
        }
        const removeFileBtn = e.target.closest('.remove-file-btn');
        if (removeFileBtn) {
            const sectionIndex = removeFileBtn.closest('.section-container').dataset.sectionIndex;
            const fileIndex = removeFileBtn.closest('.file-list-item').dataset.index;
            sections[sectionIndex].files.splice(fileIndex, 1);
            renderSections();
        }
    });

    let draggedFileIndex = null;
    let draggedSectionIndex = null;

    sectionsContainer.addEventListener('dragstart', (e) => {
        const target = e.target.closest('.file-list-item');
        if (target) {
            draggedFileIndex = parseInt(target.dataset.index, 10);
            draggedSectionIndex = parseInt(target.closest('.section-container').dataset.sectionIndex, 10);
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => target.classList.add('dragging'), 0);
        }
    });

    sectionsContainer.addEventListener('dragend', (e) => {
        const target = e.target.closest('.file-list-item');
        if(target) target.classList.remove('dragging');
        draggedFileIndex = null;
        draggedSectionIndex = null;
    });

    sectionsContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        const targetItem = e.target.closest('.file-list-item');
        if (targetItem) {
            const targetSectionIndex = parseInt(targetItem.closest('.section-container').dataset.sectionIndex, 10);
            if(targetSectionIndex === draggedSectionIndex) {
                 targetItem.closest('.file-list').querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                 targetItem.classList.add('drag-over');
            }
        }
    });
    
    sectionsContainer.addEventListener('drop', (e) => {
        e.preventDefault();
        const targetItem = e.target.closest('.file-list-item');
        if (targetItem) {
            targetItem.classList.remove('drag-over');
            const targetSectionIndex = parseInt(targetItem.closest('.section-container').dataset.sectionIndex, 10);
            if (targetSectionIndex === draggedSectionIndex) {
                const targetFileIndex = parseInt(targetItem.dataset.index, 10);
                const [draggedItem] = sections[draggedSectionIndex].files.splice(draggedFileIndex, 1);
                sections[targetSectionIndex].files.splice(targetFileIndex, 0, draggedItem);
                renderSections();
            }
        }
    });
    
    addSubjectRowBtn.addEventListener('click', () => {
        const row = document.createElement('div');
        row.className = 'detail-row flex items-center space-x-2';
        row.innerHTML = `<input type="text" class="detail-label mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" placeholder="Label"><input type="text" class="detail-value mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" placeholder="Value"><button type="button" class="remove-detail-row text-red-500 hover:text-red-700 p-1"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clip-rule="evenodd" /></svg></button>`;
        subjectDetailsContainer.appendChild(row);
    });

    subjectDetailsContainer.addEventListener('click', (e) => {
        if (e.target.closest('.remove-detail-row')) e.target.closest('.detail-row').remove();
    });

    coverImageInput.addEventListener('change', () => {
        const file = coverImageInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => { previewImg.src = e.target.result; imagePreview.classList.remove('hidden'); };
            reader.readAsDataURL(file);
        } else {
            imagePreview.classList.add('hidden');
        }
    });

    // --- PDF Generation Logic (REWRITTEN & FIXED) ---
    mergeBtn.addEventListener('click', async () => {
        if (sections.flatMap(s => s.files).length === 0) {
            statusDiv.textContent = 'Please add at least one PDF file to a section.';
            return;
        }

        statusDiv.innerHTML = '<div class="flex items-center justify-center"><div class="loader w-6 h-6 border-4 rounded-full"></div><span class="ml-3">Processing...</span></div>';
        mergeBtn.disabled = true;

        try {
            // --- PASS 1: Analyze and build a page plan ---
            statusDiv.textContent = 'Analyzing PDF files...';
            const pagePlan = [];
            const fileInfoMap = new Map();
            
            const coverImageFile = coverImageInput.files[0];
            const subjectDetails = Array.from(subjectDetailsContainer.querySelectorAll('.detail-row')).map(row => ({
                label: row.querySelector('.detail-label').value.trim(),
                value: row.querySelector('.detail-value').value.trim(),
            })).filter(item => item.label && item.value);
            
            const hasCoverPage = coverTitleInput.value.trim() || coverAuthorInput.value.trim() || coverImageFile || subjectDetails.length > 0;
            
            if (hasCoverPage) {
                pagePlan.push({ type: 'cover' });
            }

            const tocEntries = [];
            for (const section of sections) {
                if (section.files.length > 0) {
                    tocEntries.push({ type: 'section', title: section.title });
                    for (const file of section.files) {
                        tocEntries.push({ type: 'file', name: file.name, id: file.uniqueId });
                        const buffer = await file.arrayBuffer();
                        const donorPdf = await PDFDocument.load(buffer, { ignoreEncryption: true });
                        fileInfoMap.set(file.uniqueId, { pageCount: donorPdf.getPageCount() });
                    }
                }
            }
            
            const tocEntriesPerPage = 35;
            const numTocPages = Math.ceil(tocEntries.length / tocEntriesPerPage);
            for (let i = 0; i < numTocPages; i++) {
                pagePlan.push({ type: 'toc' });
            }

            for (const section of sections) {
                if (section.files.length > 0) {
                    pagePlan.push({ type: 'divider', title: section.title });
                    for (const file of section.files) {
                        const info = fileInfoMap.get(file.uniqueId);
                        for (let i = 0; i < info.pageCount; i++) {
                            pagePlan.push({ type: 'content', id: file.uniqueId, sourcePageIndex: i });
                        }
                    }
                }
            }

            // --- PASS 2: Assemble the PDF from the plan ---
            statusDiv.textContent = 'Assembling PDF document...';
            const mergedPdf = await PDFDocument.create();
            const pageRefs = [];
            const A4_SIZE = { width: 595.28, height: 841.89 };

            for (const planItem of pagePlan) {
                if (planItem.type === 'content') {
                    const file = sections.flatMap(s => s.files).find(f => f.uniqueId === planItem.id);
                    const buffer = await file.arrayBuffer();
                    const donorPdf = await PDFDocument.load(buffer, { ignoreEncryption: true });
                    const [copiedPage] = await mergedPdf.copyPages(donorPdf, [planItem.sourcePageIndex]);
                    const page = mergedPdf.addPage(copiedPage);
                    if (planItem.sourcePageIndex === 0) {
                         pageRefs.push({ id: planItem.id, ref: page.ref });
                    }
                } else {
                    const page = mergedPdf.addPage([A4_SIZE.width, A4_SIZE.height]);
                    if (planItem.type === 'divider') {
                        pageRefs.push({ title: planItem.title, ref: page.ref });
                    }
                }
            }

            // --- PASS 3: Draw content on the existing pages ---
            const tocFont = await mergedPdf.embedFont(StandardFonts.Helvetica);
            const tocBoldFont = await mergedPdf.embedFont(StandardFonts.HelveticaBold);
            const coverPageFont = await mergedPdf.embedFont(StandardFonts.TimesRoman);
            const coverPageBoldFont = await mergedPdf.embedFont(StandardFonts.TimesRomanBold);

            const refToIndexMap = new Map();
            mergedPdf.getPages().forEach((page, index) => {
                refToIndexMap.set(page.ref, index);
            });

            let pagePlanIndex = 0;
            
            if (hasCoverPage) {
                statusDiv.textContent = 'Drawing cover page...';
                const coverPage = mergedPdf.getPage(pagePlanIndex);
                const { width, height } = coverPage.getSize();
                let currentY = height - 50;

                if (coverImageFile) {
                    const imageBytes = await coverImageFile.arrayBuffer();
                    const embeddedImage = coverImageFile.type === 'image/png' ? await mergedPdf.embedPng(imageBytes) : await mergedPdf.embedJpg(imageBytes);
                    const scaledDims = embeddedImage.scaleToFit(width - 100, 150);
                    currentY -= scaledDims.height;
                    coverPage.drawImage(embeddedImage, { x: (width / 2) - (scaledDims.width / 2), y: currentY, width: scaledDims.width, height: scaledDims.height });
                    currentY -= 50;
                } else {
                    currentY = height * 0.75;
                }
                
                if (coverTitleInput.value.trim()) {
                    const title = coverTitleInput.value.trim();
                    const titleWidth = coverPageBoldFont.widthOfTextAtSize(title, 32);
                    coverPage.drawText(title, { x: (width / 2) - (titleWidth / 2), y: currentY, font: coverPageBoldFont, size: 32 });
                }

                if (subjectDetails.length > 0) {
                    const detailFontSize = 14;
                    const detailLineHeight = detailFontSize * 1.5;
                    const totalDetailHeight = subjectDetails.length * detailLineHeight;
                    let detailY = (height / 2) + (totalDetailHeight / 2) - detailLineHeight;
                    for (const detail of subjectDetails) {
                        coverPage.drawText(`${detail.label}:`, { x: 150, y: detailY, font: coverPageBoldFont, size: detailFontSize });
                        coverPage.drawText(detail.value, { x: 280, y: detailY, font: coverPageFont, size: detailFontSize, color: rgb(0.2, 0.2, 0.2) });
                        detailY -= detailLineHeight;
                    }
                }

                if (coverAuthorInput.value.trim()) {
                    const author = coverAuthorInput.value.trim();
                    const authorWidth = coverPageFont.widthOfTextAtSize(author, 14);
                    coverPage.drawText(author, { x: (width / 2) - (authorWidth / 2), y: height * 0.25, font: coverPageFont, size: 14 });
                }

                if (includeDateCheckbox.checked) {
                    const dateText = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                    const dateWidth = coverPageFont.widthOfTextAtSize(dateText, 12);
                    coverPage.drawText(dateText, { x: (width / 2) - (dateWidth / 2), y: height * 0.2, font: coverPageFont, size: 12, color: rgb(0.5, 0.5, 0.5) });
                }
                pagePlanIndex++;
            }
            
            const firstTocPageRef = numTocPages > 0 ? mergedPdf.getPage(pagePlanIndex).ref : null;

            if (numTocPages > 0) {
                statusDiv.textContent = 'Generating Table of Contents...';
                let currentTocPageNumber = 0;
                let y = A4_SIZE.height - 70;
                const lineHeight = 22;
                const sectionSpacing = 15;
                let serialNumber = 1;

                let tocPage = mergedPdf.getPage(pagePlanIndex + currentTocPageNumber);
                tocPage.drawText('Table of Contents', { x: 50, y, font: tocBoldFont, size: 24 });
                y -= 40;

                for (const entry of tocEntries) {
                     if (y < 60) {
                        currentTocPageNumber++;
                        tocPage = mergedPdf.getPage(pagePlanIndex + currentTocPageNumber);
                        y = A4_SIZE.height - 70;
                    }

                    let entryRef;
                    if (entry.type === 'section') {
                        entryRef = pageRefs.find(p => p.title === entry.title).ref;
                    } else {
                        entryRef = pageRefs.find(p => p.id === entry.id).ref;
                    }
                    
                    const targetPageIndex = refToIndexMap.get(entryRef);
                    const pageNumberText = `${targetPageIndex + 1}`;

                    if (entry.type === 'section') {
                        y -= sectionSpacing;
                        tocPage.drawText(entry.title, { x: 60, y, font: tocBoldFont, size: 14 });
                        const textWidth = tocBoldFont.widthOfTextAtSize(pageNumberText, 14);
                        tocPage.drawText(pageNumberText, { x: A4_SIZE.width - 60 - textWidth, y, font: tocBoldFont, size: 14 });
                        y -= lineHeight;
                    } else {
                        const snoText = `${serialNumber}.`;
                        tocPage.drawText(snoText, { x: 80, y, font: tocFont, size: 12 });

                        const displayName = entry.name.replace(/\.pdf$/i, '');
                        tocPage.drawText(displayName, { x: 110, y, font: tocFont, size: 12, color: rgb(0, 0.4, 0.8) });
                        
                        const textWidth = tocFont.widthOfTextAtSize(pageNumberText, 12);
                        tocPage.drawText(pageNumberText, { x: A4_SIZE.width - 60 - textWidth, y, font: tocFont, size: 12 });
                        y -= lineHeight;
                        serialNumber++;
                    }
                    
                    tocPage.node.addAnnot(mergedPdf.context.obj({
                        Type: 'Annot', Subtype: 'Link',
                        Rect: [55, y + 2, A4_SIZE.width - 55, y + lineHeight],
                        Border: [0, 0, 0],
                        A: { Type: 'Action', S: 'GoTo', D: [entryRef, 'Fit'] },
                    }));
                }
            }

            const pageCount = mergedPdf.getPageCount();
            for(let i = 0; i < pageCount; i++) {
                const page = mergedPdf.getPage(i);
                const pageType = pagePlan[i].type;
                if (pageType === 'content' && firstTocPageRef) {
                    const { width, height } = page.getSize();
                    const hotspotSize = 50;
                     page.node.addAnnot(mergedPdf.context.obj({
                         Type: 'Annot', Subtype: 'Link',
                         Rect: [width - hotspotSize - 10, 10, width - 10, 10 + hotspotSize],
                         Border: [0, 0, 0],
                         A: { Type: 'Action', S: 'GoTo', D: [firstTocPageRef, 'Fit'] },
                     }));
                }
            }
            
            // Draw Section Dividers
            const dividerPlanItems = pagePlan.filter(p => p.type === 'divider');
            for (const planItem of dividerPlanItems) {
                const dividerRef = pageRefs.find(p => p.title === planItem.title).ref;
                const pageIndex = refToIndexMap.get(dividerRef);
                if (pageIndex !== undefined) {
                    const page = mergedPdf.getPage(pageIndex);
                    page.drawText(planItem.title, { x: 70, y: A4_SIZE.height / 2, font: coverPageBoldFont, size: 32, color: rgb(0.1, 0.1, 0.2) });
                }
            }

            // Finalize and Download
            const pdfBytes = await mergedPdf.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            downloadLink.href = url;
            downloadContainer.classList.remove('hidden');
            statusDiv.textContent = '✅ Your merged PDF is ready!';
            mergeBtn.disabled = false;
        } catch (error) {
            console.error(error);
            statusDiv.textContent = `An error occurred: ${error.message}`;
            mergeBtn.disabled = false;
        }
    });

    // Initial render
    renderSections();
</script>
</body>
</html>
